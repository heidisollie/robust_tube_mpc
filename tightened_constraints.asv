function t_constraints [S, N] = tightened_constraints(problem)

i=1;
disturbance_set=Polyhedron(problem.constraints.E,problem.constraints.g);
X(i) = disturbane_set;

%this does not terminate because A_K is not Hurwitz
while noy(problem.system.A_K^i * disturbance_set <= problem.system.alpha * disturbance_set)
    i = i + 1;
    X(i) = problem.system.A_K * X(i-1) + disturbance_set;
end

S = (1 - problem.system.alpha)^(1) * X(i);
N = i;
problem.system.constraints.C_K = problem.system.constraints.C + problem.

tmp = zeros(size(problem.constraints.C,1), size(disturbance_set.V,1));
theta_N = zeros(size(problem.constraints.C,2), size(disturbance_set.V,1));

% Calculate \theta_N
for k=1:size(problem.constraints.C,1)
    c_x' = problem.constraints.C;
    c_u' = problem.constraints.D;
    d = problem.constraints.e(k,:);
    for i=1:N
        for i=1:size(disturbance_set.V, 1)
            W_vertice = disturbance_set.V(i,:)';
            tmp(k, i) = tmp(k, i) + c_x * problem.system.A_K^i * W_vertice ...
                  + c_u * problem.system.K*problem.system.A_K^i * W_vertice;
        end
    % Find maximum value for each row 
    [~, ind] = max(tmp(k,:));
    theta_N(:,i) = disturbance_set.V(ind,:)';
    end
end


t_constraints.e = problem.constraints.e - (1 - problem.system.alpha)^-1 * theta_N;
t_constraints.C = problem.constraints.C;
t_constraints.D = problem.constraints.D;
    
    
    
% Construct X_outer, {X_k}_k=0^N and {Z_k}_k=0^N
